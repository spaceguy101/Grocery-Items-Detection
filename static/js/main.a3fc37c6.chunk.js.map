{"version":3,"sources":["useModel.js","object-detection-video/useWebcam.js","object-detection-video/retina-canvas.js","object-detection-video/render-predictions.js","object-detection-video/ObjectDetectionVideo.js","index.js"],"names":["useModel","modelPath","_useState","useState","_useState2","Object","slicedToArray","model","setModel","useEffect","models","load","then","useWebcam","videoRef","onLoaded","navigator","mediaDevices","getUserMedia","audio","video","facingMode","width","ideal","height","stream","current","srcObject","onloadedmetadata","getRetinaContext","canvas","ctx","getContext","scale","window","devicePixelRatio","setWidth","w","style","setHeight","h","clearAll","clearRect","x","y","setFont","font","size","parseInt","retinaFont","replace","setTextBaseLine","textBaseline","setStrokeStyle","strokeStyle","setLineWidth","lineWidth","strokeRect","setFillStyle","fillStyle","measureText","text","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fillRect","fillText","getLabelText","prediction","concat","label","renderPredictions","predictions","textHeight","forEach","bbox","predictionText","Math","round","textWidth","border","xPadding","yPadding","ObjectDetectionVideo","React","memo","_ref","onPrediction","fit","mirrored","render","useRef","canvasRef","detectFrame","useCallback","asyncToGenerator","regenerator_default","a","mark","_callee","wantedWidth","wantedHeight","videoWidth","videoHeight","scaleX","scaleY","xOffset","yOffset","offsetPredictions","wrap","_context","prev","next","abrupt","detect","sent","offsetWidth","offsetHeight","min","max","map","objectSpread2","requestAnimationFrame","stop","position","left","top","objectFit","transform","react_default","createElement","autoPlay","playsInline","muted","ref","App","process","className","object_detection_video_ObjectDetectionVideo","target","href","rootElement","document","getElementById","ReactDOM","src_App"],"mappings":"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","file":"static/js/main.a3fc37c6.chunk.js","sourcesContent":["import { useEffect, useState } from 'react'\r\n\r\nimport models from '@cloud-annotations/models'\r\n\r\nconst useModel = (modelPath) => {\r\n  const [model, setModel] = useState()\r\n  useEffect(() => {\r\n    models.load(modelPath).then((model) => {\r\n      setModel(model)\r\n    })\r\n  }, [modelPath])\r\n  return model\r\n}\r\n\r\nexport default useModel\r\n","import { useEffect } from 'react'\r\n\r\nconst useWebcam = (videoRef, onLoaded) => {\r\n  useEffect(() => {\r\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n      navigator.mediaDevices\r\n        .getUserMedia({\r\n          audio: false,\r\n          video: {\r\n            facingMode: 'user',\r\n            width: { ideal: 4096 },\r\n            height: { ideal: 2160 },\r\n          },\r\n        })\r\n        .then((stream) => {\r\n          videoRef.current.srcObject = stream\r\n          videoRef.current.onloadedmetadata = () => {\r\n            onLoaded()\r\n          }\r\n        })\r\n    }\r\n  }, [onLoaded, videoRef])\r\n}\r\n\r\nexport default useWebcam\r\n","export const getRetinaContext = (canvas) => {\r\n  const ctx = canvas.getContext('2d')\r\n  const scale = window.devicePixelRatio\r\n  let width = canvas.width / scale\r\n  let height = canvas.height / scale\r\n  return {\r\n    setWidth: (w) => {\r\n      width = w\r\n      canvas.style.width = w + 'px'\r\n      canvas.width = w * scale\r\n    },\r\n    setHeight: (h) => {\r\n      height = h\r\n      canvas.style.height = h + 'px'\r\n      canvas.height = h * scale\r\n    },\r\n    width: width,\r\n    height: height,\r\n    clearAll: () => {\r\n      return ctx.clearRect(0, 0, width * scale, height * scale)\r\n    },\r\n    clearRect: (x, y, width, height) => {\r\n      return ctx.clearRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    setFont: (font) => {\r\n      const size = parseInt(font, 10) * scale\r\n      const retinaFont = font.replace(/^\\d+px/, size + 'px')\r\n      ctx.font = retinaFont\r\n    },\r\n    setTextBaseLine: (textBaseline) => {\r\n      ctx.textBaseline = textBaseline\r\n    },\r\n    setStrokeStyle: (strokeStyle) => {\r\n      ctx.strokeStyle = strokeStyle\r\n    },\r\n    setLineWidth: (lineWidth) => {\r\n      ctx.lineWidth = lineWidth * scale\r\n    },\r\n    strokeRect: (x, y, width, height) => {\r\n      return ctx.strokeRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    setFillStyle: (fillStyle) => {\r\n      ctx.fillStyle = fillStyle\r\n    },\r\n    measureText: (text) => {\r\n      const metrics = ctx.measureText(text)\r\n      return {\r\n        width: metrics.width / scale,\r\n        actualBoundingBoxLeft: metrics.actualBoundingBoxLeft / scale,\r\n        actualBoundingBoxRight: metrics.actualBoundingBoxRight / scale,\r\n        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent / scale,\r\n        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent / scale,\r\n      }\r\n    },\r\n    fillRect: (x, y, width, height) => {\r\n      return ctx.fillRect(x * scale, y * scale, width * scale, height * scale)\r\n    },\r\n    fillText: (text, x, y) => {\r\n      return ctx.fillText(text, x * scale, y * scale)\r\n    },\r\n  }\r\n}\r\n","const getLabelText = (prediction) => {\r\n  //const scoreText = (prediction.score * 100).toFixed(1)\r\n  return `${prediction.label}`\r\n}\r\n\r\nexport const renderPredictions = (ctx, predictions) => {\r\n  // Font options.\r\n  const font = `${16}px 'ibm-plex-sans', Helvetica Neue, Arial, sans-serif`\r\n  ctx.setFont(font)\r\n  ctx.setTextBaseLine('top')\r\n  const border = 4\r\n  const xPadding = 16\r\n  const yPadding = 8\r\n  const offset = 6\r\n  const textHeight = parseInt(font, 10) // base 10\r\n\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0]\r\n    const y = prediction.bbox[1]\r\n    const width = prediction.bbox[2]\r\n    const height = prediction.bbox[3]\r\n\r\n    const predictionText = getLabelText(prediction)\r\n\r\n    // Draw the bounding box.\r\n    ctx.setStrokeStyle('#0062ff')\r\n    ctx.setLineWidth(border)\r\n\r\n    ctx.strokeRect(\r\n      Math.round(x),\r\n      Math.round(y),\r\n      Math.round(width),\r\n      Math.round(height)\r\n    )\r\n    // Draw the label background.\r\n    ctx.setFillStyle('#0062ff')\r\n    const textWidth = ctx.measureText(predictionText).width\r\n    ctx.fillRect(\r\n      Math.round(x - border / 2),\r\n      Math.round(y - (textHeight + yPadding) - offset),\r\n      Math.round(textWidth + xPadding),\r\n      Math.round(textHeight + yPadding)\r\n    )\r\n  })\r\n\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0]\r\n    const y = prediction.bbox[1]\r\n\r\n    const predictionText = getLabelText(prediction)\r\n    // Draw the text last to ensure it's on top.\r\n    ctx.setFillStyle('#ffffff')\r\n    ctx.fillText(\r\n      predictionText,\r\n      Math.round(x - border / 2 + xPadding / 2),\r\n      Math.round(y - (textHeight + yPadding) - offset + yPadding / 2)\r\n    )\r\n  })\r\n}\r\n","import React, { useRef, useCallback } from 'react'\r\n\r\nimport useWebcam from './useWebcam'\r\nimport { getRetinaContext } from './retina-canvas'\r\nimport { renderPredictions } from './render-predictions'\r\n\r\nconst ObjectDetectionVideo = React.memo(\r\n  ({ model, onPrediction, fit, mirrored, render }) => {\r\n    const videoRef = useRef()\r\n    const canvasRef = useRef()\r\n\r\n    useWebcam(videoRef, () => {\r\n      detectFrame()\r\n    })\r\n\r\n    const detectFrame = useCallback(async () => {\r\n      if (!model) return;\r\n      const predictions = await model.detect(videoRef.current)\r\n      if (onPrediction) {\r\n        onPrediction(predictions)\r\n      }\r\n\r\n      const wantedWidth = videoRef.current.offsetWidth\r\n      const wantedHeight = videoRef.current.offsetHeight\r\n      const videoWidth = videoRef.current.videoWidth\r\n      const videoHeight = videoRef.current.videoHeight\r\n\r\n      const scaleX = wantedWidth / videoWidth\r\n      const scaleY = wantedHeight / videoHeight\r\n\r\n      let scale\r\n      if (fit === 'aspectFit') {\r\n        scale = Math.min(scaleX, scaleY)\r\n      } else {\r\n        scale = Math.max(scaleX, scaleY)\r\n      }\r\n\r\n      const xOffset = (wantedWidth - videoWidth * scale) / 2\r\n      const yOffset = (wantedHeight - videoHeight * scale) / 2\r\n\r\n      const ctx = getRetinaContext(canvasRef.current)\r\n\r\n      ctx.setWidth(wantedWidth)\r\n      ctx.setHeight(wantedHeight)\r\n      ctx.clearAll()\r\n\r\n      // Update predictions to match canvas.\r\n      const offsetPredictions = predictions.map((prediction) => {\r\n        let x = prediction.bbox[0] * scale + xOffset\r\n        const y = prediction.bbox[1] * scale + yOffset\r\n        const width = prediction.bbox[2] * scale\r\n        const height = prediction.bbox[3] * scale\r\n\r\n        if (mirrored) {\r\n          x = wantedWidth - x - width\r\n        }\r\n        return { ...prediction, bbox: [x, y, width, height] }\r\n      })\r\n\r\n      const renderFunction = render || renderPredictions\r\n\r\n      renderFunction(ctx, offsetPredictions)\r\n      requestAnimationFrame(() => {\r\n        detectFrame()\r\n      })\r\n    }, [fit, mirrored, model, onPrediction, render])\r\n\r\n    if (canvasRef.current) {\r\n      canvasRef.current.style.position = 'absolute'\r\n      canvasRef.current.style.left = '0'\r\n      canvasRef.current.style.top = '0'\r\n    }\r\n\r\n    if (videoRef.current) {\r\n      videoRef.current.style.width = '100%'\r\n      videoRef.current.style.height = '100%'\r\n      if (fit === 'aspectFit') {\r\n        videoRef.current.style.objectFit = 'contain'\r\n      } else {\r\n        videoRef.current.style.objectFit = 'cover'\r\n      }\r\n\r\n      if (mirrored) {\r\n        videoRef.current.style.transform = 'scaleX(-1)'\r\n      } else {\r\n        videoRef.current.style.transform = 'scaleX(1)'\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div style={{ position: 'relative' }}>\r\n        <video autoPlay playsInline muted ref={videoRef} />\r\n        <canvas ref={canvasRef} />\r\n      </div>\r\n    )\r\n  }\r\n)\r\n\r\nexport default ObjectDetectionVideo\r\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\n\r\nimport useModel from './useModel'\r\nimport ObjectDetectionVideo from './object-detection-video/ObjectDetectionVideo'\r\n\r\nimport './index.css'\r\n\r\nconst handlePrediction = (predictions) => {\r\n  console.timeEnd('detect')\r\n  console.time('detect')\r\n  console.log(predictions)\r\n}\r\n\r\nconst render = (ctx, predictions) => {\r\n  predictions.forEach((prediction) => {\r\n    const x = prediction.bbox[0]\r\n    const y = prediction.bbox[1]\r\n    const width = prediction.bbox[2]\r\n    const height = prediction.bbox[3]\r\n\r\n    ctx.setStrokeStyle('#0062ff')\r\n    ctx.setLineWidth(4)\r\n    ctx.strokeRect(\r\n      Math.round(x),\r\n      Math.round(y),\r\n      Math.round(width),\r\n      Math.round(height)\r\n    )\r\n  })\r\n}\r\n\r\nconst App = () => {\r\n  const model = useModel(process.env.PUBLIC_URL + '/model_web')\r\n\r\n  return (\r\n\r\n    <div className=\"main\">\r\n      <div className=\"heading-text\">Real Time Grocery Items Detection Using Tensorflow.js and IBM Watson ðŸ“¸</div>\r\n\r\n\r\n\r\n      <div className=\"video\">\r\n        <ObjectDetectionVideo\r\n          model={model}\r\n          //onPrediction={handlePrediction}\r\n          // render={render}\r\n          // aspectFill: The option to scale the video to fill the size of the view.\r\n          //             Some portion of the video may be clipped to fill the view's\r\n          //             bounds.\r\n          // aspectFit:  The option to scale the video to fit the size of the view\r\n          //             by maintaining the aspect ratio. Any remaining area of the\r\n          //             view's bounds is transparent.\r\n          fit=\"aspectFit\"\r\n        // mirrored:   mirror the video about its vertical axis.\r\n        //mirrored\r\n        />\r\n      </div>\r\n\r\n      <div className=\"small-text\">Models have been trained to detect only these items : Maggi noodles , Knorr Soup</div>\r\n\r\n      <div className=\"bottom-text\">By <a target=\"_blank\" href=\"https://shreyasponkshe.me\">Shreyas Ponkshe</a></div>\r\n    </div>\r\n  )\r\n}\r\n\r\nconst rootElement = document.getElementById('root')\r\nReactDOM.render(<App />, rootElement)\r\n"],"sourceRoot":""}